原代码
0.75 .* StartSymbol .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0) .* (DownloadTempPool < 2700 .* CodeSpeed) + ...
                           +  2 .* (~StartSymbol) .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0);      %播放时存货大于0.5秒就不下载，小于0.5秒就按0.75倍下载，停止时按1.3倍高速下载，每个rtt结算一次
误差为
    0.0665
    0.1386
    0.3016
    0.5481
    0.7294

 修改为0.55 .* StartSymbol .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0) .* (DownloadTempPool < 2700 .* CodeSpeed) + ...
    +  1.75 .* (~StartSymbol) .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0);      %播放时存货大于0.5秒就不下载，小于0.5秒就按0.75倍下载，停止时按1.3倍高速下载，每个rtt结算一次
则误差为
    0.0805
    0.1668
    0.3464
    0.5603
    0.7301
与playavgspeed在0.5——0.7之间的符合较好，且pausecount上去了

    0.55 .* StartSymbol .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0) .* (DownloadTempPool < 2700 .* CodeSpeed) + ...
    +  1.85 .* (~StartSymbol) .*  PlayAvgSpeed .* RndPAS(time) .* E2ERTT .* (mod(time, E2ERTT) == 0)
    0.0701
    0.1311
    0.2907
    0.5675
    0.7369
高速符合好一点，但低速情况下又失去了优越性

    0.0673
    0.1424
    0.2908
    0.5943
    0.7266


    
预估真实下载情况为：

计划：看卡顿时间和播放平均速率的关系，选取分段区间，致使高速时重播放门限变短，以此来得到更高的卡顿次数和卡顿时长（因为卡顿时的下载速度也变小）
观察到平均播放速率从5000开始，有一个不符合模型的突峰，大概在6000左右最密。选取5000左右设定一个新的算法。
结果：高速时出现问题，应再改进
    新模型误差
    0.0510
    0.0992
    0.2026
    0.5175
    0.7428

    0.0735
    0.1430
    0.3101
    0.5528
    0.7018

    
    0.0714
    0.1467
    0.3056
    0.5186
    0.6559
        
    
    0.0625
    0.1284
    0.2727
    0.5934
    0.8283

结论：低速情况下的情况符合得并不好，待修改